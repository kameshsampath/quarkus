include::./attributes.adoc[]
:experimental:

= {project-name} - Deploying Knative Application to Kubernetes or OpenShift

This guide covers:

* The deployment of the Knative serverless application to Kubernetes 

This guide takes as input the application developed in the link:building-native-image-guide.html[native application guide].
So, you should have been able to package your application as a binary executable, copied it in a Docker image and run this image.

Depending on whether you are a _bare_ Kubernetes user or an OpenShift user, pick the section you need.
The OpenShift section leverages OpenShift build and route features which are not available in _bare_ Kubernetes.

== Prerequisites

For this guide you need:

- roughly 20 minutes
- You have installed  https://openjdk.java.net/install/[Java SE 8 or later JDK], to try the example locally
- having access to a Kubernetes and/or OpenShift cluster. Minikube and https://try.openshift.com[OpenShift] are valid options
- having deployed Knative components on https://knative.dev/docs/install/knative-with-minikube/[Minikube]
or use https://operatorhub.io[OperatorHub] to deploy Knative on OpenShift
- having https://github.com/tektoncd/pipeline/blob/master/docs/install.md#adding-the-tekton-pipelines[installed] https://tekton.dev/[Tekton] pipelines  or 
use https://operatorhub.io[OperatorHub] to deploy Tekton on OpenShift
- https://github.com/tektoncd/cli[Tekton CLI], the cli to manage your in-cluster application builds

== Solution

We recommend to follow the instructions in the next sections and build the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `getting-started-knative` directory.

== Deploying the application in Knative

We will be using the minikube or OpenShift's internal container registry to push the built container image. 

If you are using minikube then please follow the instructions https://github.com/kameshsampath/minikube-helpers/tree/master/registry[Minikube Helpers] to setup and configure the local container registry.

[NOTE]
====
* The tests were done with minikube version 1.1.1
* You don't need extra registry setup for OpenShift
====

== Build and deploy the quickstart 

=== Using Tekton to build the application container image 

[source, bash, subs="attributes+,+macros"]
----
kubectl create --filename build/resources.yaml --filename build/task.yaml --filename build/task-run.yaml
----

Build task will take some time to complete as maven dependencies needs to be downloaded, you can watch the status of the build using the command:

[source, bash, subs="attributes+,+macros"]
----
tkn taskrun logs -f -a getting-started-knative
----

=== Deploy Knative service

Once the task is completed successfully, you can run the following command to create the Knative service:

[source, bash, subs="attributes+,+macros"]
----
 kubectl apply --filename service.yaml
----

== Accessing your application

The application is now exposed as an internal service. If you are using `minikube` or `minishift`, you can access it using:

[source,bash]
----
INGRESSGATEWAY=istio-ingressgateway
IP_ADDRESS="$(minikube ip):$(kubectl get svc $INGRESSGATEWAY --namespace istio-system --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')" #<1>

curl -v -H 'Host: getting-started-knative.default.example.com' $IP_ADDRESS/greeting/redhat
----

<1> If you are using OpenShift you can use the url of the service directly. You can get the service URL using the command `oc get -n <your project> rt getting-started-knative`

== Going further

This guide covered the deployment of a Quarkus application as Knative application on Kubernetes
However, there is much more, and the integration with these environments has been tailored to make Quarkus applications execution very smooth.
For instance, the health extension can be used for health check; the configuration support allows mounting the application configuration using config map, the metric extension produces data _scrappable_ by Prometheus and so on. You can also check the end to end https://redhat-developer-demos.github.io/knative-tutorial[Knative Tutorial] which uses Quarkus fore more advanced scenarios.

== Cleanup 

[source, bash, subs="attributes+,+macros"]
----
kubectl delete -f build
kubectl delete -f service.yaml
----
